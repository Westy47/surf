<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="color-scheme" content="dark" />
<meta name="robots" content="noindex" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>~ Terminal Navigator ~</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');

  :root {
    --color-background: #0a0a0a;
    --color-foreground: #00ff00;
    --color-prompt: #ffff00;
    --color-command: #00ffff;
    --color-text-dim: #666;
    --color-border: #333;
    --color-cursor: #00ff00;
    --font-mono: 'JetBrains Mono', 'Courier New', monospace;
    --terminal-padding: 20px;
    --line-height: 1.4;
    --cursor-blink: 1s;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
    height: 100vh;
    overflow: hidden;
  }

  body {
    background: var(--color-background);
    color: var(--color-foreground);
    font-family: var(--font-mono);
    font-size: 14px;
    line-height: var(--line-height);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .terminal {
    flex: 1;
    padding: var(--terminal-padding);
    background:
      radial-gradient(ellipse at center, rgba(0, 255, 0, 0.03) 0%, transparent 70%),
      linear-gradient(transparent 50%, rgba(0, 0, 0, 0.1) 50%);
    background-size: 100% 100%, 100% 2px;
    position: relative;
    overflow-y: auto;
  }

  .terminal::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background:
      repeating-linear-gradient(
        0deg,
        transparent 0px,
        rgba(0, 255, 0, 0.03) 1px,
        transparent 2px
      );
    pointer-events: none;
    z-index: 1;
  }

  .header {
    border-bottom: 1px solid var(--color-border);
    margin-bottom: 20px;
    padding-bottom: 10px;
    animation: typing 2s steps(40, end);
  }

  .header h1 {
    color: var(--color-prompt);
    font-weight: 700;
    text-align: center;
    text-shadow: 0 0 10px currentColor;
  }

  .header .subtitle {
    text-align: center;
    color: var(--color-text-dim);
    margin-top: 5px;
    font-size: 12px;
  }

  .commands-section {
    margin-bottom: 30px;
  }

  .section-title {
    color: var(--color-command);
    margin-bottom: 15px;
    font-weight: 700;
    text-shadow: 0 0 5px currentColor;
  }

  .commands-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 8px 20px;
    margin-left: 20px;
  }

  .command-item {
    display: flex;
    align-items: center;
    padding: 2px 0;
    text-decoration: none;
    color: inherit;
    transition: all 0.2s;
  }

  .command-item:hover {
    color: var(--color-prompt);
    text-shadow: 0 0 8px currentColor;
    transform: translateX(5px);
  }

  .command-key {
    color: var(--color-prompt);
    font-weight: 700;
    width: 30px;
    text-align: center;
    margin-right: 10px;
    background: rgba(255, 255, 0, 0.1);
    border: 1px solid rgba(255, 255, 0, 0.3);
    border-radius: 3px;
    font-size: 12px;
    padding: 2px 0;
  }

  .command-name {
    flex: 1;
  }

  .prompt-line {
    display: flex;
    align-items: center;
    margin: 20px 0;
    opacity: 0;
    animation: fadeIn 0.5s ease-in-out 2s forwards;
  }

  .prompt {
    color: var(--color-prompt);
    margin-right: 8px;
    font-weight: 700;
  }

  .cursor {
    display: inline-block;
    background: var(--color-cursor);
    color: var(--color-background);
    animation: blink var(--cursor-blink) infinite;
    padding: 0 2px;
    margin-left: 2px;
  }

  .search-dialog {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }

  .search-dialog.active {
    display: flex;
  }

  .search-container {
    width: 80%;
    max-width: 600px;
    background: var(--color-background);
    border: 2px solid var(--color-foreground);
    border-radius: 5px;
    padding: 20px;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
  }

  .search-input {
    width: 100%;
    background: transparent;
    border: none;
    outline: none;
    color: var(--color-foreground);
    font-family: var(--font-mono);
    font-size: 18px;
    padding: 10px;
    border-bottom: 1px solid var(--color-border);
    margin-bottom: 20px;
  }

  .suggestions {
    list-style: none;
    max-height: 300px;
    overflow-y: auto;
  }

  .suggestion {
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 3px;
    transition: all 0.2s;
    color: var(--color-text-dim);
  }

  .suggestion:hover,
  .suggestion.active {
    background: rgba(0, 255, 0, 0.1);
    color: var(--color-foreground);
    text-shadow: 0 0 5px currentColor;
  }

  .config-info {
    position: fixed;
    bottom: 20px;
    right: 20px;
    color: var(--color-text-dim);
    font-size: 10px;
    opacity: 0;
    animation: fadeIn 0.5s ease-in-out 3s forwards;
  }

  @keyframes typing {
    from { width: 0; }
    to { width: 100%; }
  }

  @keyframes fadeIn {
    to { opacity: 1; }
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  @media (max-width: 768px) {
    .commands-grid {
      grid-template-columns: 1fr;
      gap: 5px;
    }

    .terminal {
      padding: 15px;
    }
  }
</style>

<script>
  // Configuration centralisée - Modifiez ici pour personnaliser
  const TERMINAL_CONFIG = {
    // Configuration générale
    openLinksInNewTab: false,
    suggestionLimit: 6,
    searchEngine: 'https://duckduckgo.com/?q={}',

    // Commandes et raccourcis - Modifiez/ajoutez vos liens ici
    commands: {
      // Productivity
      'm': {
        name: 'ProtonMail',
        url: 'https://mail.proton.me/u/0/',
        category: 'productivity',
        searchTemplate: '?q={}',
        suggestions: ['mail.proton.me/u/0/', 'mail.google.com/mail/u/0/']
      },
      'c': {
        name: 'Calendar',
        url: 'https://calendar.proton.me/u/0/',
        category: 'productivity',
        suggestions: ['calendar.proton.me/u/0/', 'calendar.google.com/calendar/u/0/r']
      },
      'd': {
        name: 'Drive',
        url: 'https://drive.proton.me/u/0/',
        category: 'productivity',
        suggestions: ['https://drive.proton.me/u/0/', 'drive.google.com/drive/u/0/']
      },
      'n': {
        name: 'Notion',
        url: 'https://www.notion.so',
        category: 'productivity'
      },
      'l': {
        name: 'Linear',
        url: 'https://linear.app/',
        category: 'productivity'
      },

      // Development
      'g': {
        name: 'GitHub',
        url: 'https://github.com',
        category: 'development'
      },
      'a': {
        name: 'ArchLinux',
        url: 'https://archlinux.org',
        category: 'development'
      },
      '0': {
        name: 'localhost',
        url: 'http://localhost:3000',
        category: 'development',
        searchTemplate: ':{}',
        suggestions: ['0 3000', '0 3030', '0 54323', '0 8000', '0 32400', '0 8080']
      },

      // Entertainment
      's': {
        name: 'Spotify',
        url: 'https://open.spotify.com/',
        category: 'entertainment'
      },
      'y': {
        name: 'YouTube',
        url: 'https://youtube.com/feed/subscriptions',
        category: 'entertainment',
        searchTemplate: '/results?search_query={}'
      },
      'r': {
        name: 'Reddit',
        url: 'https://www.reddit.com',
        category: 'entertainment',
        searchTemplate: '/search?q={}',
        suggestions: [
          'r/r/archlinux',
          'r/r/kde',
          'r/r/EndeavourOS',
          'r/r/neovim'
        ]
      },

      // Tools
      'o': {
        name: 'AI Chat',
        url: 'https://chat.mistral.ai/chat',
        category: 'tools',
        suggestions: ['https://chat.mistral.ai/chat', 'https://chat.openai.com/']
      },
      't': {
        name: 'Translate',
        url: 'https://www.deepl.com/translator',
        category: 'tools'
      },
      '?': {
        name: 'Help',
        url: 'https://github.com/bouteillerAlan/tilde',
        category: 'tools'
      }
    },

    // Catégories d'affichage
    categories: {
      'productivity': 'PRODUCTIVITY',
      'development': 'DEVELOPMENT',
      'entertainment': 'ENTERTAINMENT',
      'tools': 'TOOLS'
    }
  };
</script>

<div class="terminal">
  <div class="header">
    <h1>TERMINAL NAVIGATOR v2.1</h1>
    <div class="subtitle">Press any key to search • Type letter shortcuts for quick access</div>
  </div>

  <div id="commands-container"></div>

  <div class="prompt-line">
    <span class="prompt">user@navigator:~$</span>
    <span>Press any key to start<span class="cursor">█</span></span>
  </div>
</div>

<div class="search-dialog" id="searchDialog">
  <div class="search-container">
    <input type="text" id="searchInput" class="search-input" placeholder="Enter command or search term..." autocomplete="off" spellcheck="false">
    <ul class="suggestions" id="suggestions"></ul>
  </div>
</div>

<div class="config-info">
  Config: Edit TERMINAL_CONFIG object to customize
</div>

<script>
  class TerminalNavigator {
    constructor() {
      this.currentSuggestionIndex = -1;
      this.keyPressCount = new Map();
      this.lastKeyTime = 0;
      this.keyResetDelay = 1000; // 1 seconde pour reset le compteur

      this.init();
      this.bindEvents();
      this.renderCommands();
    }

    init() {
      this.searchDialog = document.getElementById('searchDialog');
      this.searchInput = document.getElementById('searchInput');
      this.suggestionsContainer = document.getElementById('suggestions');
    }

    bindEvents() {
      document.addEventListener('keydown', (e) => this.handleKeyDown(e));
      this.searchInput.addEventListener('input', () => this.handleSearchInput());
      this.searchInput.addEventListener('keydown', (e) => this.handleSearchKeyDown(e));
      this.searchDialog.addEventListener('click', (e) => {
        if (e.target === this.searchDialog) {
          this.closeSearch();
        }
      });
    }

    renderCommands() {
      const container = document.getElementById('commands-container');
      const categorizedCommands = this.categorizeCommands();

      Object.entries(categorizedCommands).forEach(([category, commands]) => {
        if (commands.length === 0) return;

        const section = document.createElement('div');
        section.className = 'commands-section';

        const title = document.createElement('div');
        title.className = 'section-title';
        title.textContent = `> ${TERMINAL_CONFIG.categories[category] || category.toUpperCase()}`;
        section.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'commands-grid';

        commands.forEach(([key, command]) => {
          const item = document.createElement('a');
          item.className = 'command-item';
          item.href = command.url;
          if (TERMINAL_CONFIG.openLinksInNewTab) {
            item.target = '_blank';
            item.rel = 'noopener noreferrer';
          }

          const keySpan = document.createElement('span');
          keySpan.className = 'command-key';
          keySpan.textContent = key;

          const nameSpan = document.createElement('span');
          nameSpan.className = 'command-name';
          nameSpan.textContent = command.name;

          item.appendChild(keySpan);
          item.appendChild(nameSpan);
          grid.appendChild(item);
        });

        section.appendChild(grid);
        container.appendChild(section);
      });
    }

    categorizeCommands() {
      const categorized = {};

      Object.entries(TERMINAL_CONFIG.commands).forEach(([key, command]) => {
        const category = command.category || 'other';
        if (!categorized[category]) {
          categorized[category] = [];
        }
        categorized[category].push([key, command]);
      });

      // Trier par catégorie
      const orderedCategories = ['productivity', 'development', 'entertainment', 'tools', 'other'];
      const result = {};

      orderedCategories.forEach(cat => {
        if (categorized[cat]) {
          result[cat] = categorized[cat];
        }
      });

      return result;
    }

    handleKeyDown(e) {
      // Ignorer si on est déjà dans la recherche
      if (this.searchDialog.classList.contains('active')) return;

      // Empêcher les actions par défaut pour certaines touches
      if (e.key.length === 1 || e.key === 'Escape') {
        e.preventDefault();
      }

      if (e.key === 'Escape') return;

      // Si c'est un caractère typable
      if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
        this.handleLetterPress(e.key.toLowerCase());
      }
    }

    handleLetterPress(key) {
      const now = Date.now();

      // Reset le compteur si trop de temps s'est écoulé
      if (now - this.lastKeyTime > this.keyResetDelay) {
        this.keyPressCount.clear();
      }

      this.lastKeyTime = now;

      // Compter les pressions de cette touche
      const count = (this.keyPressCount.get(key) || 0) + 1;
      this.keyPressCount.set(key, count);

      // Obtenir toutes les commandes pour cette touche
      const matchingCommands = this.getCommandsForKey(key);

      if (matchingCommands.length > 0) {
        // Sélectionner la commande basée sur le nombre de pressions (cyclique)
        const selectedIndex = (count - 1) % matchingCommands.length;
        const selectedCommand = matchingCommands[selectedIndex];

        // Naviguer immédiatement
        this.navigate(selectedCommand.url);
      } else {
        // Aucune commande trouvée, ouvrir la recherche
        this.openSearch(key);
      }
    }

    getCommandsForKey(key) {
      const commands = [];
      Object.entries(TERMINAL_CONFIG.commands).forEach(([cmdKey, command]) => {
        if (cmdKey === key) {
          commands.push(command);
        }
      });
      return commands;
    }

    openSearch(initialQuery = '') {
      this.searchDialog.classList.add('active');
      this.searchInput.value = initialQuery;
      this.searchInput.focus();
      this.handleSearchInput();
    }

    closeSearch() {
      this.searchDialog.classList.remove('active');
      this.searchInput.value = '';
      this.suggestionsContainer.innerHTML = '';
      this.currentSuggestionIndex = -1;
    }

    handleSearchInput() {
      const query = this.searchInput.value.trim();

      if (!query) {
        this.suggestionsContainer.innerHTML = '';
        return;
      }

      const suggestions = this.getSuggestions(query);
      this.renderSuggestions(suggestions);
    }

    getSuggestions(query) {
      const suggestions = [];

      // Ajouter les commandes qui matchent
      Object.entries(TERMINAL_CONFIG.commands).forEach(([key, command]) => {
        if (key.includes(query.toLowerCase()) ||
            command.name.toLowerCase().includes(query.toLowerCase())) {
          suggestions.push({
            type: 'command',
            text: `${key} - ${command.name}`,
            url: command.url
          });
        }
      });

      // Ajouter les suggestions personnalisées des commandes
      Object.entries(TERMINAL_CONFIG.commands).forEach(([key, command]) => {
        if (command.suggestions && query.startsWith(key + ' ')) {
          const searchTerm = query.substring(key.length + 1);
          command.suggestions.forEach(suggestion => {
            if (suggestion.toLowerCase().includes(searchTerm.toLowerCase())) {
              suggestions.push({
                type: 'suggestion',
                text: suggestion,
                url: this.buildSearchUrl(command, searchTerm)
              });
            }
          });
        }
      });

      // Ajouter une option de recherche générale
      if (query && suggestions.length < TERMINAL_CONFIG.suggestionLimit) {
        suggestions.push({
          type: 'search',
          text: `Search: "${query}"`,
          url: TERMINAL_CONFIG.searchEngine.replace('{}', encodeURIComponent(query))
        });
      }

      return suggestions.slice(0, TERMINAL_CONFIG.suggestionLimit);
    }

    buildSearchUrl(command, searchTerm) {
      if (!command.searchTemplate) return command.url;

      const searchPath = command.searchTemplate.replace('{}', encodeURIComponent(searchTerm));
      return command.url + searchPath;
    }

    renderSuggestions(suggestions) {
      this.suggestionsContainer.innerHTML = '';
      this.currentSuggestionIndex = -1;

      suggestions.forEach((suggestion, index) => {
        const li = document.createElement('li');
        li.className = 'suggestion';
        li.textContent = suggestion.text;
        li.dataset.index = index;
        li.dataset.url = suggestion.url;

        li.addEventListener('click', () => {
          this.navigate(suggestion.url);
        });

        this.suggestionsContainer.appendChild(li);
      });
    }

    handleSearchKeyDown(e) {
      const suggestions = this.suggestionsContainer.querySelectorAll('.suggestion');

      switch (e.key) {
        case 'Escape':
          this.closeSearch();
          break;

        case 'Enter':
          e.preventDefault();
          if (this.currentSuggestionIndex >= 0) {
            const url = suggestions[this.currentSuggestionIndex].dataset.url;
            this.navigate(url);
          } else {
            // Recherche générale avec le contenu de l'input
            const query = this.searchInput.value.trim();
            if (query) {
              const url = TERMINAL_CONFIG.searchEngine.replace('{}', encodeURIComponent(query));
              this.navigate(url);
            }
          }
          break;

        case 'ArrowDown':
          e.preventDefault();
          this.currentSuggestionIndex = Math.min(
            this.currentSuggestionIndex + 1,
            suggestions.length - 1
          );
          this.updateSuggestionSelection();
          break;

        case 'ArrowUp':
          e.preventDefault();
          this.currentSuggestionIndex = Math.max(this.currentSuggestionIndex - 1, -1);
          this.updateSuggestionSelection();
          break;
      }
    }

    updateSuggestionSelection() {
      const suggestions = this.suggestionsContainer.querySelectorAll('.suggestion');

      suggestions.forEach((suggestion, index) => {
        suggestion.classList.toggle('active', index === this.currentSuggestionIndex);
      });
    }

    navigate(url) {
      const target = TERMINAL_CONFIG.openLinksInNewTab ? '_blank' : '_self';
      window.open(url, target, 'noopener,noreferrer');
      this.closeSearch();
    }
  }

  // Initialiser l'application quand la page est chargée
  document.addEventListener('DOMContentLoaded', () => {
    new TerminalNavigator();
  });
</script>